<!-- Generated by SpecStory -->

# Next steps for collection types (2025-06-13 16:21:14)

_**User**_

üéØ Next Steps Available
The next items in the TODO list are:
Insertion-Order Collections: Collections that maintain the exact order items were added (not sorted)
Generic collection guaranteed to keep its insertion order
Generic set guaranteed to keep its insertion order
Generic map guaranteed to keep its insertion order
Contiguous Memory Collections: Collections optimized for cache efficiency
Generic collection guaranteed to allocate in contiguous memory
Generic set guaranteed to allocate in contiguous memory
Generic map guaranteed to allocate in contiguous memory

---

_**Assistant**_



---

I can see you're working on a C# Containers project and need to implement insertion-order collections and contiguous memory collections. Let me first explore the current codebase structure to understand how it's organized and what already exists.

---

<details>
            <summary>Listed directory Containers ‚Ä¢ **8** results</summary>
        
| Name |
|-------|
| üìÑ `todo.md` |
| üìÑ `OrderedMap.cs` |
| üìÅ `obj` |
| üìÅ `bin` |
| üìÑ `OrderedSet.cs` |
| üìÑ `RingBuffer.cs` |
| üìÑ `OrderedCollection.cs` |
| üìÑ `Containers.csproj` |

</details>

---

Read file: Containers.sln

---

Read file: Containers/todo.md

---

Perfect! I can see that the project already has ordered collections implemented (`OrderedCollection`, `OrderedSet`, `OrderedMap`) that maintain natural order, and now needs insertion-order collections and contiguous memory collections. Let me examine the existing implementations to understand the code patterns and structure.

---

Read file: Containers/OrderedCollection.cs

---

Read file: Containers/OrderedSet.cs

---

Read file: Containers/OrderedMap.cs

---



---

Now let me also check what's in the test project to understand the testing patterns:

---

<details>
            <summary>Listed directory Containers.Test ‚Ä¢ **7** results</summary>
        
| Name |
|-------|
| üìÑ `OrderedMapTests.cs` |
| üìÑ `OrderedSetTests.cs` |
| üìÅ `obj` |
| üìÑ `RingBufferTests.cs` |
| üìÑ `OrderedCollectionTests.cs` |
| üìÑ `Containers.Test.csproj` |
| üìÅ `bin` |

</details>

---

Perfect! Now I understand the project structure. I can see we have:

1. **Existing implementations**: `OrderedCollection`, `OrderedSet`, and `OrderedMap` that maintain sorted order
2. **TODO items**: We need to implement insertion-order collections and contiguous memory collections
3. **Testing structure**: Each collection has corresponding test files

Based on the existing code patterns, I'll now implement the insertion-order collections first. Let me start with the `InsertionOrderCollection`:

---

```diff
- 
+ // Copyright (c) ktsu.dev
+ // All rights reserved.
+ // Licensed under the MIT license.
+ 
+ namespace ktsu.Containers;
+ 
+ using System.Collections;
+ using System.Diagnostics.CodeAnalysis;
+ 
+ /// <summary>
+ /// Represents a generic collection that maintains elements in insertion order.
+ /// </summary>
+ /// <remarks>
+ /// An insertion-order collection maintains elements in the exact order they were added,
+ /// preserving the insertion sequence without any sorting or reordering.
+ ///
+ /// This implementation uses a simple list structure to maintain insertion order while
+ /// providing efficient append operations and indexed access.
+ ///
+ /// This implementation supports:
+ /// <list type="bullet">
+ ///   <item>Adding elements at the end (preserving insertion order)</item>
+ ///   <item>Removing elements by value or at specific index</item>
+ ///   <item>Accessing elements by index</item>
+ ///   <item>Enumeration in insertion order</item>
+ ///   <item>Linear search for element location</item>
+ /// </list>
+ /// </remarks>
+ /// <typeparam name="T">The type of elements stored in the collection.</typeparam>
+ [SuppressMessage("Naming", "CA1710:Identifiers should have correct suffix", Justification = "InsertionOrderCollection is a known collection name")]
+ public class InsertionOrderCollection<T> : ICollection<T>, IReadOnlyCollection<T>, IReadOnlyList<T>
+ {
+ 	/// <summary>
+ 	/// The internal list that stores elements in insertion order.
+ 	/// </summary>
+ 	private readonly List<T> items;
+ 
+ 	/// <summary>
+ 	/// Gets the number of elements in the collection.
+ 	/// </summary>
+ 	public int Count => items.Count;
+ 
+ 	/// <summary>
+ 	/// Gets a value indicating whether the collection is read-only.
+ 	/// </summary>
+ 	public bool IsReadOnly => false;
+ 
+ 	/// <summary>
+ 	/// Gets the element at the specified index.
+ 	/// </summary>
+ 	/// <param name="index">The zero-based index of the element to get.</param>
+ 	/// <returns>The element at the specified index.</returns>
+ 	/// <exception cref="ArgumentOutOfRangeException">Thrown when index is out of range.</exception>
+ 	public T this[int index]
+ 	{
+ 		get
+ 		{
+ 			ArgumentOutOfRangeException.ThrowIfNegative(index);
+ 			ArgumentOutOfRangeException.ThrowIfGreaterThanOrEqual(index, Count);
+ 			return items[index];
+ 		}
+ 	}
+ 
+ 	/// <summary>
+ 	/// Initializes a new instance of the <see cref="InsertionOrderCollection{T}"/> class.
+ 	/// </summary>
+ 	public InsertionOrderCollection()
+ 	{
+ 		items = [];
+ 	}
+ 
+ 	/// <summary>
+ 	/// Initializes a new instance of the <see cref="InsertionOrderCollection{T}"/> class with initial capacity.
+ 	/// </summary>
+ 	/// <param name="capacity">The initial capacity of the collection.</param>
+ 	/// <exception cref="ArgumentOutOfRangeException">Thrown when capacity is negative.</exception>
+ 	public InsertionOrderCollection(int capacity)
+ 	{
+ 		ArgumentOutOfRangeException.ThrowIfNegative(capacity);
+ 		items = new List<T>(capacity);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Initializes a new instance of the <see cref="InsertionOrderCollection{T}"/> class with elements from an existing collection.
+ 	/// </summary>
+ 	/// <param name="collection">The collection whose elements are copied to the new insertion-order collection.</param>
+ 	/// <exception cref="ArgumentNullException">Thrown when collection is null.</exception>
+ 	public InsertionOrderCollection(IEnumerable<T> collection)
+ 	{
+ 		ArgumentNullException.ThrowIfNull(collection);
+ 		items = new List<T>(collection);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Adds an element to the end of the collection, preserving insertion order.
+ 	/// </summary>
+ 	/// <param name="item">The element to add.</param>
+ 	/// <remarks>
+ 	/// This operation has O(1) amortized time complexity.
+ 	/// The element is added at the end of the collection to maintain insertion order.
+ 	/// </remarks>
+ 	public void Add(T item)
+ 	{
+ 		items.Add(item);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Removes all elements from the collection.
+ 	/// </summary>
+ 	public void Clear() => items.Clear();
+ 
+ 	/// <summary>
+ 	/// Determines whether the collection contains the specified element.
+ 	/// </summary>
+ 	/// <param name="item">The element to locate.</param>
+ 	/// <returns>true if the element is found; otherwise, false.</returns>
+ 	/// <remarks>
+ 	/// This operation has O(n) time complexity as it performs a linear search.
+ 	/// </remarks>
+ 	public bool Contains(T item)
+ 	{
+ 		return items.Contains(item);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Copies the elements of the collection to an array, starting at the specified array index.
+ 	/// </summary>
+ 	/// <param name="array">The destination array.</param>
+ 	/// <param name="arrayIndex">The zero-based index in the destination array at which copying begins.</param>
+ 	/// <exception cref="ArgumentNullException">Thrown when array is null.</exception>
+ 	/// <exception cref="ArgumentOutOfRangeException">Thrown when arrayIndex is negative.</exception>
+ 	/// <exception cref="ArgumentException">Thrown when the destination array is too small.</exception>
+ 	public void CopyTo(T[] array, int arrayIndex)
+ 	{
+ 		ArgumentNullException.ThrowIfNull(array);
+ 		ArgumentOutOfRangeException.ThrowIfNegative(arrayIndex);
+ 		ArgumentOutOfRangeException.ThrowIfGreaterThan(arrayIndex, array.Length);
+ 		ArgumentOutOfRangeException.ThrowIfGreaterThan(Count, array.Length - arrayIndex);
+ 
+ 		items.CopyTo(array, arrayIndex);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Removes the first occurrence of the specified element from the collection.
+ 	/// </summary>
+ 	/// <param name="item">The element to remove.</param>
+ 	/// <returns>true if the element was found and removed; otherwise, false.</returns>
+ 	/// <remarks>
+ 	/// This operation has O(n) time complexity as it performs a linear search
+ 	/// and may need to shift elements to maintain insertion order.
+ 	/// </remarks>
+ 	public bool Remove(T item)
+ 	{
+ 		return items.Remove(item);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Removes the element at the specified index.
+ 	/// </summary>
+ 	/// <param name="index">The zero-based index of the element to remove.</param>
+ 	/// <exception cref="ArgumentOutOfRangeException">Thrown when index is out of range.</exception>
+ 	/// <remarks>
+ 	/// This operation has O(n) time complexity as it may need to shift elements
+ 	/// to maintain insertion order.
+ 	/// </remarks>
+ 	public void RemoveAt(int index)
+ 	{
+ 		ArgumentOutOfRangeException.ThrowIfNegative(index);
+ 		ArgumentOutOfRangeException.ThrowIfGreaterThanOrEqual(index, Count);
+ 
+ 		items.RemoveAt(index);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Searches for the specified element and returns the zero-based index of the first occurrence.
+ 	/// </summary>
+ 	/// <param name="item">The element to locate.</param>
+ 	/// <returns>The zero-based index of the first occurrence of the element, or -1 if not found.</returns>
+ 	/// <remarks>
+ 	/// This operation has O(n) time complexity as it performs a linear search.
+ 	/// </remarks>
+ 	public int IndexOf(T item)
+ 	{
+ 		return items.IndexOf(item);
+ 	}
+ 
+ 	/// <summary>
+ 	/// Returns an enumerator that iterates through the collection in insertion order.
+ 	/// </summary>
+ 	/// <returns>An enumerator for the collection.</returns>
+ 	public IEnumerator<T> GetEnumerator() => items.GetEnumerator();
+ 
+ 	/// <summary>
+ 	/// Returns an enumerator that iterates through the collection.
+ 	/// </summary>
+ 	/// <returns>An enumerator for the collection.</returns>
+ 	IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
+ 
+ 	/// <summary>
+ 	/// Creates a shallow copy of a range of elements in the collection.
+ 	/// </summary>
+ 	/// <param name="startIndex">The zero-based starting index of the range.</param>
+ 	/// <param name="count">The number of elements in the range.</param>
+ 	/// <returns>A new collection containing the specified range of elements.</returns>
+ 	/// <exception cref="ArgumentOutOfRangeException">Thrown when startIndex or count is invalid.</exception>
+ 	public InsertionOrderCollection<T> GetRange(int startIndex, int count)
+ 	{
+ 		ArgumentOutOfRangeException.ThrowIfNegative(startIndex);
+ 		ArgumentOutOfRangeException.ThrowIfNegative(count);
+ 		ArgumentOutOfRangeException.ThrowIfGreaterThan(startIndex + count, Count);
+ 
+ 		return new InsertionOrderCollection<T>(items.GetRange(startIndex, count));
+ 	}
+ 
+ 	/// <summary>
+ 	/// Creates a shallow copy of the collection.
+ 	/// </summary>
+ 	/// <returns>A new collection containing all elements from the original collection.</returns>
+ 	public InsertionOrderCollection<T> Clone() => new(items);
+ } 
```

---

Now let me create the `InsertionOrderSet`:

---



---



---



---

Let me try creating the file with a different approach since the file doesn't exist yet:

---

<details>
            <summary>Searched codebase "InsertionOrderSet.cs" ‚Ä¢ **1** results</summary>
        
| File |
|------|
| `undefined` |

</details>

---

I need to use a different approach to create the file. Let me create it with a simple structure first:

---

```bash
cd /c%3A/dev/ktsu-dev/Containers/Containers && type NUL > InsertionOrderSet.cs
```

```
C:\dev\ktsu-dev\Containers>cd /c%3A/dev/ktsu-dev/Containers/Containers && type NUL > InsertionOrderSet.cs
The system cannot find the path specified.

Microsoft Windows [Version 10.0.26100.4351]
(c) Microsoft Corporation. All rights reserved.

C:\dev\ktsu-dev\Containers>cd /c%3A/dev/ktsu-dev/Containers/Containers && type NUL > InsertionOrderSet.cs
The system cannot find the path specified.

C:\dev\ktsu-dev\Containers>





















C:\dev\ktsu-dev\Containers>
```

---



---

```bash
cd Containers && type NUL > InsertionOrderSet.cs
```

```
C:\dev\ktsu-dev\Containers>cd Containers && type NUL > InsertionOrderSet.cs

C:\dev\ktsu-dev\Containers\Containers>
```

---



---

Now let me add the content to the file:

---



---



---

Let me check the content of the file to see what's there:

---

Read file: Containers/InsertionOrderSet.cs

---



---

Great! The `InsertionOrderSet` was successfully created. Now let me create the `InsertionOrderMap`:

---



---



---

Let me create the file first and then add the content:

---

```bash
cd Containers && echo. > InsertionOrderMap.cs
```

```
C:\dev\ktsu-dev\Containers\Containers>cd Containers && echo. > InsertionOrderMap.cs
C:\dev\ktsu-dev\Containers\Containers>
```

---



---



---



---

Let me read the current file and then replace its contents:

---

Read file: Containers/InsertionOrderMap.cs

---



---

Perfect! It looks like all three insertion-order collections are already created. Now let me work on the contiguous memory collections. Let me start by updating the TODO file to mark the insertion-order collections as complete and check what needs to be implemented next:

---



---



---

Now let me implement the contiguous memory collections. Let me start with the `ContiguousCollection`:

---



---



---

Let me create the file first:

---

```bash
cd Containers && echo. > ContiguousCollection.cs
```

```
C:\dev\ktsu-dev\Containers\Containers>cd Containers && echo. > ContiguousCollection.cs
C:\dev\ktsu-dev\Containers\Containers>
```

---



---

Now let me add the content. I need to add the missing `using System.Runtime.CompilerServices;` for the `RuntimeHelpers` class:

---



---



---

Let me check what's in the file first:

---

Read file: Containers/ContiguousCollection.cs

---



---

I need to add the missing `using System.Runtime.CompilerServices;` statement. Let me do that:

---



---



---

Let me fix the linter errors:

---



---





---

